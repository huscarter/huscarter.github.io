<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>数据结构整理 | Here to stay</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><meta name="generator" content="Hexo 5.4.2"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">数据结构整理</h1><a id="logo" href="/.">Here to stay</a><p class="description">huscarter</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">数据结构整理</h1><div class="post-meta">2020-08-09<span> | </span><span class="category"><a href="/categories/computics/">computics</a><a href="/categories/computics/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></span></div><div class="post-content"><p>数据结构主要是要了解它的底层存储模型（数组、链表、map之类），是否线程安全，它加对象的方法，获取对象的方法，是否是有序这五点。</p>
<h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection<interface></h2><h3 id="List-extends-Collection"><a href="#List-extends-Collection" class="headerlink" title="List extends Collection"></a>List<interface> extends Collection</h3><h4 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h4><p>底层基于数组实现，多用于查询，线程安全（因为Vector的操作方法大多增加了synchronized锁） </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Vectore extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123;</span><br><span class="line">    protected Object[] elementData; // 保存数据的数组</span><br><span class="line">    protected int elementCount;// 实际数据的数量</span><br><span class="line">    protected int capacityIncrement;// 容量增长系数</span><br><span class="line"></span><br><span class="line">    Vector()&#123; // 默认构造函数</span><br><span class="line">         this(10); // 默认的capacity容量大小</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // capacity是Vector的默认容量大小。当由于增加数据导致容量增加时，每次容量会增加一倍（Arrays.copyOf(elementData, newCapacity)）</span><br><span class="line">    Vector(int capacity)</span><br><span class="line">    </span><br><span class="line">    Vector(int capacity, int capacityIncrement)// capacity是Vector的默认容量大小，capacityIncrement是每次Vector容量增加时的增量值</span><br><span class="line">    </span><br><span class="line">    Vector(Collection&lt;? extends E&gt; collection)// 创建一个包含collection的Vector</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><ol>
<li>底层基于数组实现，多用于查询，线程不安全<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private int size;  // 实际元素个数</span><br><span class="line">transient Object[] elementData; // 保存数据的数组</span><br><span class="line">// 增长系数为1.5，如果太小增赋值所需的容量，如果太大则赋值Integer.MAX_VALUE </span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><ol>
<li>底层基于链表实现，多用于插入和删除，线程不安全。</li>
<li>属于双联表，get(index)查询时会判断index和链表长度，超过一半从末尾查，小于一半从开始查。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable&#123;</span><br><span class="line">    transient int size = 0;</span><br><span class="line">    transient Node&lt;E&gt; first;</span><br><span class="line">    </span><br><span class="line">    transient Node&lt;E&gt; last;</span><br><span class="line">    </span><br><span class="line">    public LinkedList(. &#123;</span><br><span class="line">        //</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public LinkedList(Collection&lt;? extends E&gt; c. &#123;</span><br><span class="line">        this();</span><br><span class="line">        addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //</span><br><span class="line">    private static class Node&lt;E&gt; &#123;</span><br><span class="line">        E item;</span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line">        Node&lt;E&gt; prev;</span><br><span class="line">        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next. &#123;</span><br><span class="line">            this.item = element;</span><br><span class="line">            this.next = next;</span><br><span class="line">            this.prev = prev;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="Set-extends-Collection"><a href="#Set-extends-Collection" class="headerlink" title="Set extends Collection"></a>Set<interface> extends Collection</h3><h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h4><ol>
<li>无序存储数据，不能重复，可存储null，通底层过HashMap实现（将数据保存到HashMap的Key，value统一为Object()）。线程不安全。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class HashSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements Set&lt;E&gt;, Cloneable, java.io.Serializable &#123;  </span><br><span class="line">    static final long serialVersionUID = -5024744406713321676L;  </span><br><span class="line">    private transient HashMap&lt;E, Object&gt; map;  // 底层使用HashMap来保存HashSet中所有元素。  </span><br><span class="line">  </span><br><span class="line">    private static final Object PRESENT = new Object();// 定义一个虚拟的Object对象作为HashMap的value，将此对象定义为static final。  </span><br><span class="line">    public HashSet(. &#123;  </span><br><span class="line">        map = new HashMap&lt;E, Object&gt;();  </span><br><span class="line">    &#125;  </span><br><span class="line">    public boolean add(E e. &#123;  </span><br><span class="line">        return map.put(e, PRESENT. == null;  </span><br><span class="line">    &#125; </span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h4><ol>
<li>有序存储数据，不能重复，可以存储null，底层通过 TreeMap 实现，排序通过二叉树的排序实现。线程不安全。</li>
<li>因为有顺序所以存储的对象需要实现Comparable接口、或者给TreeSet构造器传入Comparator实现类。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class TreeSet&lt;E&gt; extends AbstractSet&lt;E&gt;    implements NavigableSet&lt;E&gt;, Cloneable, java.io.Serializable&#123;</span><br><span class="line">    private transient NavigableMap&lt;E,Object&gt; m;        //PRESENT会被当做Map的value与key构建成键值对 </span><br><span class="line">    private static final Object PRESENT = new Object();</span><br><span class="line">    </span><br><span class="line">    TreeSet()// 默认构造函数。使用该构造函数，TreeSet中的元素按照自然排序进行排列。</span><br><span class="line">    </span><br><span class="line">    TreeSet(Comparator&lt;? super E&gt; comparator)// 指定TreeSet的比较器</span><br><span class="line"></span><br><span class="line">    public boolean add(E e. &#123;</span><br><span class="line">        return m.put(e, PRESENT)==null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h4><ol>
<li>根据插入的顺序排列，不能重复，可以存储null，底层通过 LinkedHashMap 实现。线程不安全。</li>
</ol>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><h4 id="HashMap（jdk1-8加入了红黑树）"><a href="#HashMap（jdk1-8加入了红黑树）" class="headerlink" title="HashMap（jdk1.8加入了红黑树）"></a>HashMap（jdk1.8加入了红黑树）</h4><ol>
<li>基于Map实现、可null键/值、非同步、不保证有序(比如插入的顺序)、也不保证顺序不随时间变化.<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K, V&gt; implements Map&lt;K, V&gt;, Cloneable, Serializable&#123;</span><br><span class="line">    static final int DEFAULT_INITIAL_CAPACITY = 16; // 默认存储容量</span><br><span class="line">    static final int MAXIMUM_CAPACITY = 1073741824; // 2的31次方-1；</span><br><span class="line">    static final float DEFAULT_LOAD_FACTOR = 0.75F; // 默认扩容因子</span><br><span class="line">    static final int TREEIFY_THRESHOLD = 8; // 链表最大长度</span><br><span class="line">    static final int MIN_TREEIFY_CAPACITY = 64; // 树形化最小容量（链表的4倍）</span><br><span class="line">    transient HashMap.Node&lt;K, V&gt;[] table; // 存储数据的数组</span><br><span class="line">    transient int size; // Node节点总数（数组+链表+树）</span><br><span class="line">    int threshold; // = capacity（数组容量） * loadFactor（扩容因子）</span><br><span class="line"></span><br><span class="line">    // 数组存储对象</span><br><span class="line">    static class Node&lt;K, V&gt; implements Entry&lt;K, V&gt; &#123;</span><br><span class="line">            final int hash;</span><br><span class="line">            final K key;</span><br><span class="line">            V value;</span><br><span class="line">            HashMap.Node&lt;K, V&gt; next; // 服务于链表</span><br><span class="line">    </span><br><span class="line">            Node(int hash, K key, V value, HashMap.Node&lt;K, V&gt; next. &#123;</span><br><span class="line">                this.hash = hash;</span><br><span class="line">                this.key = key;</span><br><span class="line">                this.value = value;</span><br><span class="line">                this.next = next;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>添加数据过程</li>
<li>1 第一次会初始化Node数组（默认长度16）；计算数组下表index，index位置没有值直接插入数据。</li>
<li>2 如果index位置有值，判断hash和key是否相等，相等则覆盖原有Node。</li>
<li>3 如果发生碰撞，判断该位置存放的是否是TreeNode，如果是调用TreeNode.putTreeVal插入树中</li>
<li>4 如果不是TreeNode节点说明是链表，则添加至链表尾部。最后检查链表的长度是否超过链表阈值8，是的化将链表转为红黑树。</li>
<li>5 只有原值覆盖会返回旧值，不会出发size++；否则都会size+1和阈值（threshold = capacity * loadFactor）比较，如果size大于阈值会进行扩容。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">// 获取hash值</span><br><span class="line">static final int hash(Object key. &#123;</span><br><span class="line">    int h;</span><br><span class="line">    // 如果为 null 则返回的就是 0，否则就是 hashCode 异或上（hashCode 无符号右移 16 位）</span><br><span class="line">    return (key == null. ? 0 : (h = key.hashCode(). ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取index。自己抽离获取数组下表的方法，原HashMap类是没有的，单独拿出来方便记忆</span><br><span class="line">// hash:hash(Object key);n:table.length</span><br><span class="line">static final int index(int hash,int n)&#123;</span><br><span class="line">    return hash &amp; (n -1);// 按位与获得，等于（hash%n）</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// HashMap的put方法最终会执行此方法</span><br><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict. &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">    // tab为空则通过resize()创建，插入第 1 个值的时候发生</span><br><span class="line">    if ((tab = table. == null || (n = tab.length. == 0)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    // 计算散列 index，没有冲突直接插入</span><br><span class="line">    if ((p = tab[i = (n - 1. &amp; hash]. == null)</span><br><span class="line">        tab[i] = newNode(hash, key, value, null);</span><br><span class="line">    // 有冲突</span><br><span class="line">    else &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">       // 存在 hash 值相同且 key 相等的，先记录下来，后面的插入步骤会使用新值将旧值替换掉</span><br><span class="line">        if (p.hash == hash &amp;&amp; ((k = p.key. == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        // 该节点为树，散列冲突过长，大于 TREEIFY_THRESHOLD = 8 时会转换成树</span><br><span class="line">        else if (p instanceof TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">        // 该节点为链表</span><br><span class="line">        else &#123;</span><br><span class="line">            for (int binCount = 0; ; ++binCount. &#123;</span><br><span class="line">                if ((e = p.next. == null. &#123;</span><br><span class="line">                    // 插入到链尾</span><br><span class="line">                    p.next = newNode(hash, key, value, null);</span><br><span class="line">                    // 链表的长度超过 TREEIFY_THRESHOLD - 1 则转换成树</span><br><span class="line">                    if (binCount &gt;= TREEIFY_THRESHOLD - 1. // -1 for 1st</span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                // 在链表中又相同的key，替换node</span><br><span class="line">                if (e.hash == hash &amp;&amp; ((k = e.key. == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                    break;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 插入 existing mapping for key</span><br><span class="line">        if (e != null. &#123; </span><br><span class="line">            // 取出旧值，onlyIfAbsent此时为 false，所以不管 oldValue 有与否，都拿新值来替换</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            if (!onlyIfAbsent || oldValue == null)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    // 超过阈值 threshold = capacity * factor，调用 resize(. 进行扩容</span><br><span class="line">        resize();</span><br><span class="line">    if (++size &gt; threshold)</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    return null;</span><br><span class="line">&#125; // end putVal</span><br></pre></td></tr></table></figure></li>
<li>扩容过程（如果resize方法被调用意味着除了达到最大容量否则都会出发扩容或则初始化）</li>
<li>1 如果是初始化，容量为默认的16，阈值threshold为capacity * loadFactor = 12。</li>
<li>2 不是初始化，容量扩大1 倍，阈值也是扩大1倍。</li>
<li>3 如果扩大的容量大于最大容量（2的30次方-1），取最大容量。</li>
<li>4 如果当前容量已经为最大容量不扩容，通过碰撞存数据。</li>
<li>5 创建扩容后数组，将原数组的数据移入新数组中，因为新组数的长度发生了变化所以存入的数据都需要重新计算index。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">// 扩容会对性能会造成十分严重的影响，看下resize的具体内容</span><br><span class="line">final Node&lt;K,V&gt;[] resize(. &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    int oldCap = (oldTab == null. ? 0 : oldTab.length;</span><br><span class="line">    int oldThr = threshold;</span><br><span class="line">    int newCap, newThr = 0;</span><br><span class="line">    if (oldCap &gt; 0. &#123;</span><br><span class="line">        // 超过最大值就不再扩充 table，但并不表示不能插入了，只是后面的只能碰撞冲突了</span><br><span class="line">        if (oldCap &gt;= MAXIMUM_CAPACITY. &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            return oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        // 没超过最大值，就扩充为原来的 2 倍。主要是容量以及阈值都为原来的 2倍。容量和阈值本身就都必须是2的幂，所以扩容的倍数必须是2的倍数，那么扩2倍就非常合理了。</span><br><span class="line">        else if ((newCap = oldCap &lt;&lt; 1. &lt; MAXIMUM_CAPACITY &amp;&amp;  oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; 1; // double threshold</span><br><span class="line">    &#125;</span><br><span class="line">    else if (oldThr &gt; 0. // initial capacity was placed in threshold</span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    else &#123; // zero initial threshold signifies using defaults</span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    // 计算新的resize阈值</span><br><span class="line">    if (newThr == 0. &#123;</span><br><span class="line">        float ft = (float)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line">    // 重新分配内存</span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    if (oldTab != null. &#123;</span><br><span class="line">        // 把原来 tables 中的每个节点都移动到新的 tables 中</span><br><span class="line">        for (int j = 0; j &lt; oldCap; ++j. &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            if ((e = oldTab[j]. != null. &#123;</span><br><span class="line">                oldTab[j] = null;</span><br><span class="line">                if (e.next == null)// 没有冲突，那重新计算下位置</span><br><span class="line">                    newTab[e.hash &amp; (newCap - 1)] = e;</span><br><span class="line">                else if (e instanceof TreeNode)// 冲突的是一棵树节点，分裂成 2 个树，或者如果树很小就转成链表</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</span><br><span class="line">                else &#123; // preserve order，冲突构成的是链表</span><br><span class="line">                    Node&lt;K,V&gt; loHead = null, loTail = null;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = null, hiTail = null;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    do &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        // 索引不变</span><br><span class="line">                        if ((e.hash &amp; oldCap. == 0. &#123;</span><br><span class="line">                            if (loTail == null)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            else</span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        // 原索引+oldCap</span><br><span class="line">                        else &#123;</span><br><span class="line">                            if (hiTail == null)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            else</span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; while ((e = next. != null);</span><br><span class="line">                    // 原索引放到 tables 里</span><br><span class="line">                    if (loTail != null. &#123;</span><br><span class="line">                        loTail.next = null;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    // 原索引+oldCap放到  tables 里</span><br><span class="line">                    if (hiTail != null. &#123;</span><br><span class="line">                        hiTail.next = null;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return newTab;</span><br><span class="line">&#125; // end resize</span><br></pre></td></tr></table></figure>
<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/0a70ce2d3b67">参考</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/LiaHon/p/11149644.html">参考</a></li>
</ol>
<h4 id="LinkedHashMap-extends-HashMap"><a href="#LinkedHashMap-extends-HashMap" class="headerlink" title="LinkedHashMap extends HashMap"></a>LinkedHashMap extends HashMap</h4><ol>
<li>基于HashMap，并且通过增加head和tai以及自定义Entry（比Node多了before和after）实现双链表达到有序存储的功能。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class LinkedHashMap&lt;K, V&gt; extends HashMap&lt;K, V&gt; implements Map&lt;K, V&gt; &#123;</span><br><span class="line">    transient LinkedHashMap.Entry&lt;K, V&gt; head; // 头节点</span><br><span class="line">    transient LinkedHashMap.Entry&lt;K, V&gt; tail; // 尾节点</span><br><span class="line">    final boolean accessOrder; // 是否通过访问调整顺序，true：访问过将对象放置最末尾</span><br><span class="line"></span><br><span class="line">    // 自定义Entry</span><br><span class="line">    static class Entry&lt;K, V&gt; extends Node&lt;K, V&gt; &#123;</span><br><span class="line">        LinkedHashMap.Entry&lt;K, V&gt; before; // 前一节点</span><br><span class="line">        LinkedHashMap.Entry&lt;K, V&gt; after; // 下一个节点</span><br><span class="line"></span><br><span class="line">        Entry(int var1, K var2, V var3, Node&lt;K, V&gt; var4. &#123;</span><br><span class="line">            super(var1, var2, var3, var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>put对象和HashMap的put的逻辑一样，区别是在newNode(hash, key, value, null)方法。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; e. &#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p = new LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e);</span><br><span class="line">    // 调用此方法将存储的对象放置链表末尾</span><br><span class="line">    linkNodeLast(p);</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br><span class="line">// 放置末尾方法，服务于putVal方法，无视 accessOrder 属性</span><br><span class="line">private void linkNodeLast(LinkedHashMap.Entry&lt;K,V&gt; p. &#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last = tail;</span><br><span class="line">    tail = p;</span><br><span class="line">    if (last == null)</span><br><span class="line">        head = p;</span><br><span class="line">    else &#123;</span><br><span class="line">        p.before = last;</span><br><span class="line">        last.after = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>get方法和HashMap的区别是多了 accessOrder 的逻辑，如果accessOrder为true会调用afterNodeAccess方法。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key. &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    if ((e = getNode(hash(key), key). == null)</span><br><span class="line">        return null;</span><br><span class="line">    if (accessOrder)</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">    return e.value;</span><br><span class="line">&#125;</span><br><span class="line">// 总结一点就是将访问的当前对象放到最末尾，只有在accessOrder==true时起作用。</span><br><span class="line">void afterNodeAccess(Node&lt;K,V&gt; e. &#123;</span><br><span class="line">    //在执行方法前的上一次的尾结点</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">    //当accessOrder为true并且传入的节点并不是上一次的尾结点时,执行下面的方法</span><br><span class="line">    if (accessOrder &amp;&amp; (last = tail. != e. &#123;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p = (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">        //p：当前节点，b：当前节点的前一个节点，a：当前节点的后一个节点；</span><br><span class="line">        p.after = null;</span><br><span class="line">        if (b == null)</span><br><span class="line">            head = a;</span><br><span class="line">        else</span><br><span class="line">            b.after = a;</span><br><span class="line">        if (a != null)</span><br><span class="line">            a.before = b;</span><br><span class="line">        else</span><br><span class="line">            last = b;</span><br><span class="line">        if (last == null)</span><br><span class="line">            head = p;</span><br><span class="line">        else &#123;</span><br><span class="line">            p.before = last;</span><br><span class="line">            last.after = p;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = p;</span><br><span class="line">        ++modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>移除链表中最老的对象，但在JDK8中不会执行。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void afterNodeInsertion(boolean evict. &#123; // possibly remove eldest</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">    if (evict &amp;&amp; (first = head. != null &amp;&amp; removeEldestEntry(first). &#123;</span><br><span class="line">        K key = first.key;</span><br><span class="line">        removeNode(hash(key), key, null, false, true);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 如有需要，请自己重写此返回值</span><br><span class="line">protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest. &#123;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a target="_blank" rel="noopener" href="https://www.cnblogs.com/LiaHon/p/11180869.html">参考</a></li>
</ol>
<h4 id="TreeMap（会有Key值的比较器，使用默认比较器时Key值不能为null）"><a href="#TreeMap（会有Key值的比较器，使用默认比较器时Key值不能为null）" class="headerlink" title="TreeMap（会有Key值的比较器，使用默认比较器时Key值不能为null）"></a>TreeMap（会有Key值的比较器，使用默认比较器时Key值不能为null）</h4><ol>
<li>基于红黑树存储的Map（底层没有数组），通过Key值比较大小，也可以自己传入Comparator比较器。</li>
<li>HashMap适用于快速查找，LinkedHashMap适用于按操作顺序查找，TreeMap适用于按排序的统计查找。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class TreeMap&lt;K, V&gt; extends AbstractMap&lt;K, V&gt; implements NavigableMap&lt;K, V&gt;, Cloneable, Serializable &#123;</span><br><span class="line">    private final Comparator&lt;? super K&gt; comparator; // 比较器</span><br><span class="line">    private transient TreeMap.Entry&lt;K, V&gt; root; // 根节点</span><br><span class="line">    private transient int size = 0; // entry个数</span><br><span class="line">    private transient TreeMap&lt;K, V&gt;.EntrySet entrySet;</span><br><span class="line">    private transient TreeMap.KeySet&lt;K&gt; navigableKeySet;</span><br><span class="line">    private transient NavigableMap&lt;K, V&gt; descendingMap;</span><br><span class="line">    private static final boolean RED = false;</span><br><span class="line">    private static final boolean BLACK = true;</span><br><span class="line"></span><br><span class="line">    static final class Entry&lt;K, V&gt; implements java.util.Map.Entry&lt;K, V&gt; &#123;</span><br><span class="line">        K key;</span><br><span class="line">        V value;</span><br><span class="line">        TreeMap.Entry&lt;K, V&gt; left;</span><br><span class="line">        TreeMap.Entry&lt;K, V&gt; right;</span><br><span class="line">        TreeMap.Entry&lt;K, V&gt; parent;</span><br><span class="line">        boolean isBlck = true;</span><br><span class="line"></span><br><span class="line">        Entry(K var1, V var2, TreeMap.Entry&lt;K, V&gt; var3. &#123;</span><br><span class="line">            this.key = var1;</span><br><span class="line">            this.value = var2;</span><br><span class="line">            this.parent = var3;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>put对象，就是将entry插入到红黑树的过程</li>
<li>1 如果是第一次插入，作为跟节点即可。</li>
<li>2 不是第一次查找是否，通过比较器二分法查找key值相同的节点进行替换</li>
<li>3 没有相同的key节点，在末尾插入节点</li>
<li>4 调用fixAfterInsertion进行红黑树的合规维护。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value. &#123;</span><br><span class="line">    Entry&lt;K,V&gt; t = root;</span><br><span class="line">    // 如果根节点都为null，还没建立起来红黑树，我们先new Entry并赋值给root把红黑树建立起来，这个时候红黑树中已经有一个节点了，同时修改操作+1。</span><br><span class="line">    if (t == null. &#123;</span><br><span class="line">        compare(key, key); </span><br><span class="line">        root = new Entry&lt;&gt;(key, value, null);</span><br><span class="line">        size = 1;</span><br><span class="line">        modCount++;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果节点不为null,定义一个cmp，这个变量用来进行二分查找时的比较；定义parent，是new Entry时必须要的参数</span><br><span class="line">    int cmp;</span><br><span class="line">    Entry&lt;K,V&gt; parent;</span><br><span class="line">    // cpr表示有无自己定义的排序规则，分两种情况遍历执行</span><br><span class="line">    Comparator&lt;? super K&gt; cpr = comparator;</span><br><span class="line">    if (cpr != null. &#123;</span><br><span class="line">        /**</span><br><span class="line">         * 从root节点开始遍历，通过二分查找逐步向下找</span><br><span class="line">         * 第一次循环：从根节点开始，这个时候parent就是根节点，然后通过自定义的排序算法</span><br><span class="line">         * cpr.compare(key, t.key)比较传入的key和根节点的key值，如果传入的key&lt;root.key，那么</span><br><span class="line">         * 继续在root的左子树中找，从root的左孩子节点（root.left）开始：如果传入的key&gt;root.key,</span><br><span class="line">         * 那么继续在root的右子树中找，从root的右孩子节点（root.right）开始;如果恰好key==root.key，</span><br><span class="line">         * 那么直接根据root节点的value值即可。</span><br><span class="line">         * 后面的循环规则一样，当遍历到的当前节点作为起始节点，逐步往下找</span><br><span class="line">         *</span><br><span class="line">         * 需要注意的是：这里并没有对key是否为null进行判断，建议自己的实现Comparator时应该要考虑在内</span><br><span class="line">         */</span><br><span class="line">        do &#123;</span><br><span class="line">            parent = t;</span><br><span class="line">            cmp = cpr.compare(key, t.key);</span><br><span class="line">            if (cmp &lt; 0)</span><br><span class="line">                t = t.left;</span><br><span class="line">            else if (cmp &gt; 0)</span><br><span class="line">                t = t.right;</span><br><span class="line">            else</span><br><span class="line">                return t.setValue(value);</span><br><span class="line">        &#125; while (t != null);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        //从这里看出，当默认排序时，key值是不能为null的</span><br><span class="line">        if (key == null)</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">        Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;. key;</span><br><span class="line">        //这里的实现逻辑和上面一样，都是通过二分查找，就不再多说了</span><br><span class="line">        do &#123;</span><br><span class="line">            parent = t;</span><br><span class="line">            cmp = k.compareTo(t.key);</span><br><span class="line">            if (cmp &lt; 0)</span><br><span class="line">                t = t.left;</span><br><span class="line">            else if (cmp &gt; 0)</span><br><span class="line">                t = t.right;</span><br><span class="line">            else</span><br><span class="line">                return t.setValue(value);</span><br><span class="line">        &#125; while (t != null);</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 能执行到这里，说明前面并没有找到相同的key,节点已经遍历到最后了，我们只需要new一个Entry放到</span><br><span class="line">     * parent下面即可，但放到左子节点上还是右子节点上，就需要按照红黑树的规则来。</span><br><span class="line">     */</span><br><span class="line">    Entry&lt;K,V&gt; e = new Entry&lt;&gt;(key, value, parent);</span><br><span class="line">    if (cmp &lt; 0)</span><br><span class="line">        parent.left = e;</span><br><span class="line">    else</span><br><span class="line">        parent.right = e;</span><br><span class="line">    /**</span><br><span class="line">     * 节点加进去了，并不算完，我们在前面红黑树原理章节提到过，一般情况下加入节点都会对红黑树的结构造成</span><br><span class="line">     * 破坏，我们需要通过一些操作来进行自动平衡处置，如【变色】【左旋】【右旋】</span><br><span class="line">     */</span><br><span class="line">    fixAfterInsertion(e);</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>get数据，就是红黑树的查找。<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/LiaHon/p/11221634.html">参考</a></li>
</ol>
<h4 id="Hashtable（线程安全，key、value都不能为null）"><a href="#Hashtable（线程安全，key、value都不能为null）" class="headerlink" title="Hashtable（线程安全，key、value都不能为null）"></a>Hashtable（线程安全，key、value都不能为null）</h4><ol>
<li>Hashtable 是针对 HashMap 线程安全的一种实现（在操作方法前添加了Synchronized关键字）</li>
<li>由于会直接调用key.hashCode，key不能为null；在put方法总会判断value == null而抛出异常，所以value也不能为null</li>
<li>数组索引方式和HashMap不一样（HashTable底层的扩容方式不一样，是通过hashCode &amp; 0x7FFFFFFF. % tab.length）</li>
<li>扩容方式和HashMap不一样（默认容量为11，扩容为原来的2倍+1）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class Hashtable&lt;K, V&gt; extends Dictionary&lt;K, V&gt; implements Map&lt;K, V&gt;, Cloneable, Serializable &#123;</span><br><span class="line">    private transient Hashtable.Entry&lt;?, ?&gt;[] table;</span><br><span class="line">    private transient int count;</span><br><span class="line">    private int threshold;</span><br><span class="line">    private float loadFactor;</span><br><span class="line">    private transient int modCount;</span><br><span class="line">    private static final int MAX_ARRAY_SIZE = 2147483639;</span><br><span class="line">    private transient volatile Set&lt;K&gt; keySet;</span><br><span class="line">    private transient volatile Set&lt;java.util.Map.Entry&lt;K, V&gt;&gt; entrySet;</span><br><span class="line">    private transient volatile Collection&lt;V&gt; values;</span><br><span class="line">    private static final int KEYS = 0;</span><br><span class="line">    private static final int VALUES = 1;</span><br><span class="line">    private static final int ENTRIES = 2;</span><br><span class="line"></span><br><span class="line">    private static class Entry&lt;K, V&gt; implements java.util.Map.Entry&lt;K, V&gt; &#123;</span><br><span class="line">        final int hash;</span><br><span class="line">        final K key;</span><br><span class="line">        V value;</span><br><span class="line">        Hashtable.Entry&lt;K, V&gt; next;</span><br><span class="line"></span><br><span class="line">        protected Entry(int var1, K var2, V var3, Hashtable.Entry&lt;K, V&gt; var4. &#123;</span><br><span class="line">            this.hash = var1;</span><br><span class="line">            this.key = var2;</span><br><span class="line">            this.value = var3;</span><br><span class="line">            this.next = var4;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="ConcurrentHashMap（jdk1-7和jdk1-8的实现又大变化）-1-8版本put方法会判KV空抛出错误"><a href="#ConcurrentHashMap（jdk1-7和jdk1-8的实现又大变化）-1-8版本put方法会判KV空抛出错误" class="headerlink" title="ConcurrentHashMap（jdk1.7和jdk1.8的实现又大变化）(1.8版本put方法会判KV空抛出错误)"></a>ConcurrentHashMap（jdk1.7和jdk1.8的实现又大变化）(1.8版本put方法会判KV空抛出错误)</h4><ol>
<li><p>jdk1.7</p>
</li>
<li><p>1 外层通过数组存储segment，通过segment实现真是数据HashEntry的操作。</p>
</li>
<li><p>2 segment继承自ReentrantLock<a href="java/java%E7%BA%BF%E7%A8%8B%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86">java线程知识梳理</a>，通过数组+链表存储数据。(ReentrantLock对象提供手动锁和解锁，可实现公平锁，响应中断和限时等待的功能)</p>
</li>
<li><p>3 添加对象</p>
</li>
<li><p>3.1 如果是第一次会进行segment数组初始化和调用ensureSegment初始化当前segment。</p>
</li>
<li><p>3.2 ConcurrentHashMap现通过Hash值、segmentShift和SegmentMark算出segment组数的下表获取segment，调用segment.put方法。</p>
</li>
<li><p>3.3 segment的put方法添加对象和HashMap大致相同，区别在于开头和结尾会调用自身的lock和unlock以达到线程安全，因为HashEntry的next为final，所以新添加的元素会放在表头。（获取锁时有个自旋等待过程）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">final V put(K key, int hash, V value, boolean onlyIfAbsent) &#123;</span><br><span class="line">    // 是否获取锁,失败自旋获取锁(直到成功)</span><br><span class="line">    HashEntry&lt;K,V&gt; node = tryLock() ? null : scanAndLockForPut(key, hash, value);</span><br><span class="line">    V oldValue;</span><br><span class="line">    try &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">        // 定义位置</span><br><span class="line">        int index = (tab.length - 1) &amp; hash;</span><br><span class="line">        // 获取第一个桶的第一个元素</span><br><span class="line">        // entryAt 底层调用getObjectVolatile 具有volatile读语义</span><br><span class="line">        HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br><span class="line">        for (HashEntry&lt;K,V&gt; e = first;;) &#123;</span><br><span class="line">            if (e != null) &#123; // 证明链式结构有数据 遍历节点数据替换,直到e=null</span><br><span class="line">                K k;</span><br><span class="line">                if ((k = e.key) == key || (e.hash == hash &amp;&amp; key.equals(k))) &#123; //  找到了相同的key</span><br><span class="line">                    oldValue = e.value;</span><br><span class="line">                    if (!onlyIfAbsent) &#123; // 默认值false</span><br><span class="line">                        e.value = value; // 替换value</span><br><span class="line">                        ++modCount;</span><br><span class="line">                    &#125;</span><br><span class="line">                    break; // 结束循环</span><br><span class="line">                &#125;</span><br><span class="line">                e = e.next;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123; // e=null (1) 之前没有数据 (2) 没有找到替换的元素</span><br><span class="line">                // node是否为空,这个获取锁的是有关系的</span><br><span class="line">                // (1) node不为null,设置node的next为first</span><br><span class="line">                // (2) node为null,创建头节点,指定next为first</span><br><span class="line">                if (node != null)</span><br><span class="line">                    // 底层使用 putOrderedObject 方法 具有volatile写语义</span><br><span class="line">                    node.setNext(first);</span><br><span class="line">                else</span><br><span class="line">                    node = new HashEntry&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line">                int c = count + 1;</span><br><span class="line">                // 扩容条件 (1)entry数量大于阈值 (2) 当前table的数量小于最大容量  满足以上条件就扩容</span><br><span class="line">                if (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                    // 扩容方法,方法里面具体讲</span><br><span class="line">                    rehash(node);</span><br><span class="line">                else</span><br><span class="line">                    // 给table的index位置设置为node,</span><br><span class="line">                    // node为头结点,原来的头结点first为node的next节点</span><br><span class="line">                    // 底层也是调用的 putOrderedObject 方法 具有volatile写语义</span><br><span class="line">                    setEntryAt(tab, index, node);</span><br><span class="line">                ++modCount;</span><br><span class="line">                count = c;</span><br><span class="line">                oldValue = null;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    return oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>4 扩容数组。算法类似HashMap，当素组元素个数&gt;阈值（数组长度*负载因子）时将容量扩大到原来的2被，此时元素的都需要重新计算数组下标。</p>
</li>
<li><p>5 get新元素。get方法没有加锁，原因是segment的数组使用了volatile修饰，而且HashEntry的的属性（value和next）也都是volatile，其余（hash和k）为final，确保了读取的是最新的数据。</p>
</li>
<li><p>jdk1.8</p>
</li>
<li><p>1 底层和HashMap即为相似都是数组搭配链表和红黑树。</p>
</li>
<li><p>2 线程安全通过Synchronized和CAS（compare and set）<a href="java/java%E7%BA%BF%E7%A8%8B%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86">java线程知识梳理</a>实现。</p>
</li>
<li><p>3 添加对象。</p>
</li>
<li><p>3.1 第一次put会现初始化table数组。</p>
</li>
<li><p>3.2 通过hash计算出数组的下表，如果没有元素则通过cas添加，此时没有加锁。</p>
</li>
<li><p>3.3 如果该下表有元素，通过Node.hash == MOVED(MOVED == -1)判断是否处于数组扩容阶段，如果是则加入扩容复制元素任务中。</p>
</li>
<li><p>3.4 如果不在扩容阶段，则采用Synchronized对该下表的元素加锁进入链表或则红黑树的添加阶段。</p>
</li>
<li><p>3.5 添加完会判断链表或则数组长度。如果数组长度&gt;阈值则扩容至原来的2倍，如果链表的长度&gt;8且数组容量&gt;64则将链表转红黑树。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">final V putVal(K key, V value, boolean onlyIfAbsent) &#123;</span><br><span class="line">    if (key == null || value == null) throw new NullPointerException(); //K,V都不能为空，否则的话跑出异常</span><br><span class="line">    int hash = spread(key.hashCode()); //取得key的hash值</span><br><span class="line">    int binCount = 0; //用来计算在这个节点总共有多少个元素，用来控制扩容或者转移为树</span><br><span class="line">    for (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; int n, i, fh;</span><br><span class="line">        if (tab == null || (n = tab.length) == 0)    </span><br><span class="line">            tab = initTable(); //第一次put的时候table没有初始化，则初始化table</span><br><span class="line">        //通过哈希计算出一个表中的位置因为n是数组的长度，所以(n-1)&amp;hash肯定不会出现数组越界</span><br><span class="line">        else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) &#123;</span><br><span class="line">            //如果这个位置没有元素的话，则通过cas的方式尝试添加，注意这个时候是没有加锁的 。创建一个Node添加到数组中区，null表示的是下一个节点为空</span><br><span class="line">            if (casTabAt(tab, i, null, new Node&lt;K,V&gt;(hash, key, value, null))) </span><br><span class="line">                break; // no lock when adding to empty bin</span><br><span class="line">        &#125;</span><br><span class="line">        /*</span><br><span class="line">         * 如果检测到某个节点的hash值是MOVED，则表示正在进行数组扩张的数据复制阶段，</span><br><span class="line">         * 则当前线程也会参与去复制，通过允许多线程复制的功能，一次来减少数组的复制所带来的性能损失</span><br><span class="line">         */</span><br><span class="line">        else if ((fh = f.hash) == MOVED)    </span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        else &#123;</span><br><span class="line">            /*</span><br><span class="line">             * 如果在这个位置有元素的话，就采用synchronized的方式加锁，</span><br><span class="line">             * 如果是链表的话(hash大于0)，就对这个链表的所有元素进行遍历，</span><br><span class="line">             * 如果找到了key和key的hash值都一样的节点，则把它的值替换到</span><br><span class="line">             * 如果没找到的话，则添加在链表的最后面</span><br><span class="line">             * 否则，是树的话，则调用putTreeVal方法添加到树中去</span><br><span class="line">             * 在添加完之后，会对该节点上关联的的数目进行判断，</span><br><span class="line">             * 如果在8个以上的话，则会调用treeifyBin方法，来尝试转化为树，或者是扩容</span><br><span class="line">             */</span><br><span class="line">            V oldVal = null;</span><br><span class="line">            synchronized (f) &#123;</span><br><span class="line">                if (tabAt(tab, i) == f) &#123; //再次取出要存储的位置的元素，跟前面取出来的比较</span><br><span class="line">                    if (fh &gt;= 0) &#123; //取出来的元素的hash值大于0，当转换为树之后，hash值为-2</span><br><span class="line">                        binCount = 1;            </span><br><span class="line">                        for (Node&lt;K,V&gt; e = f;; ++binCount) &#123; //遍历这个链表</span><br><span class="line">                            K ek;</span><br><span class="line">                            //要存的元素的hash，key跟要存储的位置的节点的相同的时候，替换掉该节点的value即可</span><br><span class="line">                            if (e.hash == hash &amp;&amp; ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                if (!onlyIfAbsent) //当使用putIfAbsent的时候，只有在这个key没有设置值得时候才设置</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                break;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            if ((e = e.next) == null) &#123; //如果不是同样的hash，同样的key的时候，则判断该节点的下一个节点是否为空，</span><br><span class="line">                                pred.next = new Node&lt;K,V&gt;(hash, key,value, null); //为空的话把这个要加入的节点设置为当前节点的下一个节点</span><br><span class="line">                                break;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else if (f instanceof TreeBin) &#123;    //表示已经转化成红黑树类型了</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = 2;</span><br><span class="line">                        //调用putTreeVal方法，将该元素添加到树中去</span><br><span class="line">                        if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key, value)) != null) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            if (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (binCount != 0) &#123;</span><br><span class="line">                if (binCount &gt;= TREEIFY_THRESHOLD) //当在同一个节点的数目达到8个的时候，则扩张数组或将给节点的数据转为tree</span><br><span class="line">                    treeifyBin(tab, i);    </span><br><span class="line">                if (oldVal != null)</span><br><span class="line">                    return oldVal;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addCount(1L, binCount); //计数</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>4 扩容算法和HashMap一样</p>
</li>
<li><p>5 get对象。get没有使用Synchronized和cas控制。原因是 Node 的属性（value和next）也都是volatile，其余（hash和k）为final，确保了读取的是最新的数据。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; int n, eh; K ek;</span><br><span class="line">    int h = spread(key.hashCode());</span><br><span class="line">    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">        (e = tabAt(tab, (n - 1) &amp; h)) != null) &#123;</span><br><span class="line">        if ((eh = e.hash) == h) &#123;</span><br><span class="line">            if ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))</span><br><span class="line">                return e.val;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (eh &lt; 0)</span><br><span class="line">            return (p = e.find(h, key)) != null ? p.val : null;</span><br><span class="line">        while ((e = e.next) != null) &#123;</span><br><span class="line">            if (e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek))))</span><br><span class="line">                return e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zerotomax/p/8687425.html">参考</a></p>
<h2 id="Linked-lt-一种设计思想-gt"><a href="#Linked-lt-一种设计思想-gt" class="headerlink" title="Linked&lt;一种设计思想&gt;"></a>Linked&lt;一种设计思想&gt;</h2><p>链表在物理内存上不连续也无序，通过元素的指针达到逻辑有序。</p>
<ol>
<li>优点：增删快，时间都是O(1)；内存申请高效不需要连续地址。</li>
<li>缺点：查询比数组慢，时间是O(n)。</li>
</ol>
<h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><ol>
<li><p>包含本身的数据外，还有一个指向下一个元素的引用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Node &#123;</span><br><span class="line">    public Object data;</span><br><span class="line">    public Node next;</span><br><span class="line">    </span><br><span class="line">    public Node(Object data,Node next)&#123;</span><br><span class="line">        this.data = data;</span><br><span class="line">        this.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>添加元素</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void add(Object data)&#123;</span><br><span class="line">    Node temp = this.last;</span><br><span class="line">    Node current = new Node(data,null)</span><br><span class="line">    this.last = current;</span><br><span class="line">    if(temp == null)&#123; // 说明此时添加的是第一个节点</span><br><span class="line">        this.first = current;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        temp.next = current;</span><br><span class="line">    &#125;</span><br><span class="line">    this.size ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>元素获取</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 获取列表中第index个元素</span><br><span class="line">public Node get(int index)&#123;</span><br><span class="line">    if(index &gt; this.size-1)&#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    Node temp = this.first;</span><br><span class="line">    for(int i =0; i&lt;index ;i++ )&#123;</span><br><span class="line">        temp = temp.next;</span><br><span class="line">    &#125;</span><br><span class="line">    return temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h3><ol>
<li><p>包含本身数据外，还有2个引用，一个指向前一个节点，一个指向后一个节点。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Node &#123;</span><br><span class="line">    public Object data;</span><br><span class="line">    public Node prev;</span><br><span class="line">    public Node next;</span><br><span class="line">    </span><br><span class="line">    public Node(Object data,Node next,Node prev)&#123;</span><br><span class="line">        this.data = data;</span><br><span class="line">        this.next = next;</span><br><span class="line">        this.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>添加元素</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void add(Object data)&#123;</span><br><span class="line">    Node temp = this.last;</span><br><span class="line">    Node current = new Node(data,null,temp) // Node(Object data,Node next,Node prev)</span><br><span class="line">    this.last = current;</span><br><span class="line">    if(temp == null)&#123; // 说明此时添加的是第一个节点</span><br><span class="line">        this.first = current;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        temp.next = current;</span><br><span class="line">    &#125;</span><br><span class="line">    this.size ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>元素获取</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 获取列表中第index个元素，因为是双链表可以从后向前查询，所以当index&gt;(size&gt;&gt;1)时，从last开始向前迭代</span><br><span class="line">public Node get(int index)&#123;</span><br><span class="line">    if(index &gt; this.size-1)&#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    Node temp;</span><br><span class="line">    if(index&lt;(this.size&gt;&gt;1))&#123;</span><br><span class="line">        temp = this.first;</span><br><span class="line">        for(int i =0; i&lt;index ;i++ )&#123;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        temp = this.last;</span><br><span class="line">        for(int i =0; i&gt;-1 ;i-- )&#123;</span><br><span class="line">            temp = temp.prev;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="树结构"><a href="#树结构" class="headerlink" title="树结构"></a>树结构</h2><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><h4 id="二叉的排序树"><a href="#二叉的排序树" class="headerlink" title="二叉的排序树"></a>二叉的排序树</h4><ol>
<li>左子树上所有节点的值均小于它的根节点的值;</li>
<li>右子树上所有节点的值均大于它的根节点的值。</li>
</ol>
<h4 id="平衡二叉树（AVL）"><a href="#平衡二叉树（AVL）" class="headerlink" title="平衡二叉树（AVL）"></a>平衡二叉树（AVL）</h4><p>二叉排序树因为插入的顺序有可能编程一个链表(比如顺序为1、2、3)，为了避免此情况发生而出现了平衡二叉树</p>
<ol>
<li>要求两个子树的高度差不能超过1;</li>
<li>每次增删都会通过一次或多次旋转来平衡二叉树。</li>
<li>1 插入到不平衡节点左子树的左边需要RR（右旋）</li>
<li>2 插入到不平衡节点又子树的右边需要LL（左旋）</li>
<li>3 插入到不平衡节点左子树的右边需要LR（先左再右旋）</li>
<li>4 插入到不平衡节点右子树的左边需要RL（先右再左旋）</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://baijiahao.baidu.com/s?id=1646617486319372351&wfr=spider&for=pc">参考</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/f556f7fa6f35">参考</a></p>
<h4 id="红黑树（R-B-Tree）"><a href="#红黑树（R-B-Tree）" class="headerlink" title="红黑树（R-B Tree）"></a>红黑树（R-B Tree）</h4><p>在大量查找的情况下，平衡二叉树的效率更高，也是首要选择。在大量增删的情况下平衡二叉树因为需要保持左右树高度差不能超过1，所以需要频繁旋转。<br>红黑树就称为了首选（最多3此旋转）。Java集合中的TreeSet和TreeMap，以及Linux虚拟内存的管理，都是通过红黑树去实现的。</p>
<ol>
<li>节点要么黑要么红；</li>
<li>根节点一定时黑色；</li>
<li>所有叶节点都为null，且为黑色；</li>
<li>红色节点的两个子节点都为黑色，不会有两个连续的红；</li>
<li>任意一个路径上的黑节点数，一定时相等的。（保证查询和平衡二叉树效率一样，算是不严格的平衡二叉树）<br><a target="_blank" rel="noopener" href="https://baijiahao.baidu.com/s?id=1645429373049393021&wfr=spider&for=pc">参考</a></li>
</ol>
<h3 id="多路叉树"><a href="#多路叉树" class="headerlink" title="多路叉树"></a>多路叉树</h3><h4 id="B-Trees（平衡多路查找树，b为balance）"><a href="#B-Trees（平衡多路查找树，b为balance）" class="headerlink" title="B-Trees（平衡多路查找树，b为balance）"></a>B-Trees（平衡多路查找树，b为balance）</h4><p>主要使用在文件系统中。</p>
<ol>
<li>每个节点最多有m个孩子。 </li>
<li>除了根节点和叶子节点外，其它每个节点至少有Ceil(m/2)个孩子。 </li>
<li>若根节点不是叶子节点，则至少有2个孩子 </li>
<li>所有叶子节点都在同一层，且不包含其它关键字信息 </li>
<li>每个非终端节点包含n个关键字信息（P0,P1,…Pn, k1,…kn）</li>
<li>关键字的个数n满足：ceil(m/2)-1 &lt;= n &lt;= m-1 </li>
<li>ki(i=1,…n)为关键字，且关键字升序排序。 </li>
<li>Pi(i=1,…n)为指向子树根节点的指针。P(i-1)指向的子树的所有节点关键字均小于ki，但都大于k(i-1)</li>
</ol>
<h4 id="B-Trees"><a href="#B-Trees" class="headerlink" title="B+Trees"></a>B+Trees</h4><p>所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，而非叶子节点上只存储key值信息；实现文件索引结构方面比B树使用得更普遍</p>
<ol>
<li>非叶子节点只存储键值信息。</li>
<li>所有叶子节点之间都有一个链指针。</li>
<li>数据记录都存放在叶子节点中。</li>
</ol>
<h2 id="栈-先进后出"><a href="#栈-先进后出" class="headerlink" title="栈(先进后出)"></a>栈(先进后出)</h2><p>栈的数据结构具有先进后出的特点（FILO first in last out），一般是通过数组加上业务控制模拟。</p>
<h2 id="队列（队列先进先出）"><a href="#队列（队列先进先出）" class="headerlink" title="队列（队列先进先出）"></a>队列（队列先进先出）</h2><p>队列数据结构具有先进先出的特点（FIFO），通过peek可以访问第一个元素，通过poll可以访问并删除第一个元素。</p>
<h3 id="单端队列"><a href="#单端队列" class="headerlink" title="单端队列"></a>单端队列</h3><p>单端队列从末尾来添加、删除元素。通过offer将元素放到尾部。</p>
<ol>
<li>PriorityQueue<br>PriorityQueue是一个比较标准的队列实现类，它会根据元素的大小排列（元素不能为null），所以其实不是FIFO。</li>
</ol>
<h3 id="双端队列（Deque-extends-Queue）"><a href="#双端队列（Deque-extends-Queue）" class="headerlink" title="双端队列（Deque extends Queue）"></a>双端队列（Deque<interface> extends Queue）</h3><p>双端队列可以同时从两端来添加、删除元素。通过push将元素押入头部，通过offer将元素放到尾部。</p>
<ol>
<li><p>ArrayDeque<br>底层通过数组实现，可以通过numElement指定长度，默认是16。</p>
</li>
<li><p>LinkedList<br>参考List部分。</p>
</li>
</ol>
<h2 id="android特定的数据结构"><a href="#android特定的数据结构" class="headerlink" title="android特定的数据结构"></a>android特定的数据结构</h2><h3 id="Map部分"><a href="#Map部分" class="headerlink" title="Map部分"></a>Map部分</h3><h4 id="ArrayMap（获取key的hash值时做了判空处理，所以key可为null）"><a href="#ArrayMap（获取key的hash值时做了判空处理，所以key可为null）" class="headerlink" title="ArrayMap（获取key的hash值时做了判空处理，所以key可为null）"></a>ArrayMap（获取key的hash值时做了判空处理，所以key可为null）</h4><ol>
<li><p>ArrayMap底层有2个数组，一个用来存储Key的HashCode（是有序存储），另一个用来存储Key和Value，所以第二个数组的长度是第一个数组的2倍。</p>
</li>
<li><p>添加数据（分为put和append，append作用于插入元素的HashCode大于数组中现有的值时，否则内部依然会调用put）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    final int hash;</span><br><span class="line">    int index;</span><br><span class="line">    if (key == null) &#123;//key为空时，取hash值为定值0</span><br><span class="line">        hash = 0;</span><br><span class="line">        index = indexOfNull();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //根据mIdentityHashCode判断是否使用固定的hash值</span><br><span class="line">        hash = mIdentityHashCode ? System.identityHashCode(key) : key.hashCode();</span><br><span class="line">        index = indexOf(key, hash);//通过hash值计算下标值,最终也是使用的二分查找</span><br><span class="line">    &#125;</span><br><span class="line">    if (index &gt;= 0) &#123;//如果找到了，说明之前已经put过这个key值了，这时直接覆盖对应value值</span><br><span class="line">        //mHashes数组中的index值，对应的value值在mArray中index*2+1处</span><br><span class="line">        index = (index&lt;&lt;1) + 1;</span><br><span class="line">        final V old = (V)mArray[index];//记录旧值</span><br><span class="line">        mArray[index] = value;//覆盖旧值，增加新的value值</span><br><span class="line">        return old;</span><br><span class="line">    &#125;</span><br><span class="line">    //如果index&lt;0，也就是没有根据key的hash值在mhashes数组中找到对应的下标值</span><br><span class="line">    index = ~index;//哇，经典复现！！！（具体SparseArray里才讲过）获取key的hash值要插入的位置</span><br><span class="line">    if (mSize &gt;= mHashes.length) &#123;//如果数组容量已满</span><br><span class="line">        //获取扩容的大小，这个就是一个稍显复杂的三目运算符，应该--问题不大！就不赘述了，嘿嘿</span><br><span class="line">        final int n = mSize &gt;= (BASE_SIZE*2)?(mSize+(mSize&gt;&gt;1)):(mSize &gt;= BASE_SIZE?(BASE_SIZE*2):BASE_SIZE);</span><br><span class="line">        //接下来这三步，进行了allocArrays一个操作，我们暂且不管，放一放，待会再来收拾它</span><br><span class="line">        final int[] ohashes = mHashes;</span><br><span class="line">        final Object[] oarray = mArray;</span><br><span class="line">        allocArrays(n);</span><br><span class="line">        //将旧的数组赋值给进行allocArrays操作之后的数组</span><br><span class="line">        if (mHashes.length &gt; 0) &#123;</span><br><span class="line">            if (DEBUG) Log.d(TAG, &quot;put: copy 0-&quot; + mSize + &quot; to 0&quot;);</span><br><span class="line">            System.arraycopy(ohashes, 0, mHashes, 0, ohashes.length);</span><br><span class="line">            System.arraycopy(oarray, 0, mArray, 0, oarray.length);</span><br><span class="line">        &#125;</span><br><span class="line">        //进行一个叫freeArrays的操作，我们和allocArrays一样，待会再来收拾它</span><br><span class="line">        freeArrays(ohashes, oarray, mSize);</span><br><span class="line">    &#125;</span><br><span class="line">    //如果待插入的位置小于mSize,则需要将mHashes数组index的位置空出来，相应的后面元素后移</span><br><span class="line">    //同时mArray数组中index*2和index*2+1这两个位置也要空出来，相应的后面的元素后移</span><br><span class="line">    if (index &lt; mSize) &#123;</span><br><span class="line">        System.arraycopy(mHashes, index, mHashes, index + 1, mSize - index);</span><br><span class="line">        System.arraycopy(mArray, index &lt;&lt; 1, mArray, (index + 1) &lt;&lt; 1, (mSize - index) &lt;&lt; 1);</span><br><span class="line">    &#125;</span><br><span class="line">    //呼！终于可以进行插入操作了</span><br><span class="line">    mHashes[index] = hash;</span><br><span class="line">    mArray[index&lt;&lt;1] = key;</span><br><span class="line">    mArray[(index&lt;&lt;1)+1] = value;</span><br><span class="line">    mSize++;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>添加、删除元素出发的数组容量维护（ArrayMap的缓存机制）。<br>大致逻辑将数组的0下标位指向上一个混存数组，数组的1下标位指向当前hashCode数组，其他位置置空。这样形成一个缓存数组链表。<br>每次扩容为BASE_SIZE/BASE_SIZE*2时，就利用响应缓存链表的头数组，这样避免了频繁在内存新建和销魂数组对象。<br><img src="ArrayMap%E7%9A%84%E7%BC%93%E5%AD%98%E6%A8%A1%E5%9E%8B.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">// 缓存数组</span><br><span class="line">private static void freeArrays(final int[] hashes, final Object[] array, final int size) &#123;</span><br><span class="line">    //参数hashes数组对应mHashes数组   参数array数组对应mArray数组  size代表容器元素数量</span><br><span class="line">    if (hashes.length == (BASE_SIZE*2)) &#123;</span><br><span class="line">        synchronized (ArrayMap.class) &#123;//防止多线程不同步</span><br><span class="line">            //如果没有达到缓存数量上限</span><br><span class="line">            if (mTwiceBaseCacheSize &lt; CACHE_SIZE) &#123;</span><br><span class="line">                array[0] = mTwiceBaseCache;//将array的第一个元素指向缓存数组</span><br><span class="line">                array[1] = hashes;//将array的第二个元素指向hashes数组</span><br><span class="line">                for (int i=(size&lt;&lt;1)-1; i&gt;=2; i--) &#123;</span><br><span class="line">                    array[i] = null;//将从下标2起始的位置，全部置空，释放空间</span><br><span class="line">                &#125;</span><br><span class="line">                //将缓存数组指向设置完毕的array数组</span><br><span class="line">                //也就是将array数组添加到缓存数组的链表头</span><br><span class="line">                mTwiceBaseCache = array;</span><br><span class="line">                mTwiceBaseCacheSize++;//缓存完毕，缓存数组的数量加一</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (hashes.length == BASE_SIZE) &#123;//完全一样的逻辑，同上</span><br><span class="line">        synchronized (ArrayMap.class) &#123;</span><br><span class="line">            if (mBaseCacheSize &lt; CACHE_SIZE) &#123;</span><br><span class="line">                array[0] = mBaseCache;</span><br><span class="line">                array[1] = hashes;</span><br><span class="line">                for (int i=(size&lt;&lt;1)-1; i&gt;=2; i--) &#123;</span><br><span class="line">                    array[i] = null;</span><br><span class="line">                &#125;</span><br><span class="line">                mBaseCache = array;</span><br><span class="line">                mBaseCacheSize++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 分配容量（获取混存数组）</span><br><span class="line">private void allocArrays(final int size) &#123;</span><br><span class="line">    //mHashes数组容量为0，直接抛出异常</span><br><span class="line">    //EMPTY_IMMUTABLE_INTS这个值是mHashes数组的初始值,是一个大小为0的int数组</span><br><span class="line">    //直接写mHashes.length==0不好吗，真是一个奇怪的作者，莫非暗藏玄机？暂且留作疑问</span><br><span class="line">    if (mHashes == EMPTY_IMMUTABLE_INTS) &#123;</span><br><span class="line">        throw new UnsupportedOperationException(&quot;ArrayMap is immutable&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //如果大小为BASE_SIZE*2=8，这时缓存使用mTwiceBaseCache数组来缓存</span><br><span class="line">    if (size == (BASE_SIZE*2)) &#123;</span><br><span class="line">        synchronized (ArrayMap.class) &#123;//防止多线程操作带来的不同步</span><br><span class="line">            if (mTwiceBaseCache != null) &#123;</span><br><span class="line">                final Object[] array = mTwiceBaseCache;</span><br><span class="line">                //将mArray指向mTwiceBaseCache（相当于缓存链表的头指针）</span><br><span class="line">                //初始化mArray的大小（其实里面0号位置和1号位置也有数据，只不过没有意义）</span><br><span class="line">                mArray = array;</span><br><span class="line">                //将mTwiceBaseCache的指针指向头节点数组的0号元素，也就是指向第二个缓存数组</span><br><span class="line">                mTwiceBaseCache = (Object[])array[0];</span><br><span class="line">                //获取头节点数组array的1号元素指向的hash值数组，并赋给mHashes数组</span><br><span class="line">                mHashes = (int[])array[1];</span><br><span class="line">                //将mTwiceBaseCache缓存链表的头节点0号元素和1号元素置空，释放</span><br><span class="line">                array[0] = array[1] = null;</span><br><span class="line">                //缓存数组的数量减一</span><br><span class="line">                mTwiceBaseCacheSize--;</span><br><span class="line">                return;//结束</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (size == BASE_SIZE) &#123;//使用mBaseCache数组来缓存，同上</span><br><span class="line">        synchronized (ArrayMap.class) &#123;</span><br><span class="line">            if (mBaseCache != null) &#123;</span><br><span class="line">                final Object[] array = mBaseCache;</span><br><span class="line">                mArray = array;</span><br><span class="line">                mBaseCache = (Object[])array[0];</span><br><span class="line">                mHashes = (int[])array[1];</span><br><span class="line">                array[0] = array[1] = null;</span><br><span class="line">                mBaseCacheSize--;</span><br><span class="line">                return;//结束</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //如果size既不等于BASE_SIZE，也不等于BASE_SIZE*2</span><br><span class="line">    //那么就new新的数组来初始化mHashes和mArray，里面数据均为空，相当于没有使用缓存</span><br><span class="line">    mHashes = new int[size];</span><br><span class="line">    mArray = new Object[size&lt;&lt;1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>获取数据。通过二分法查找hashCode数组下标index，第二个数组对应的key和value下标就是index&lt;&lt;1和index&lt;&lt;1+1。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">    final int index = indexOfKey(key);//二分查找获取下标</span><br><span class="line">    //mHashes数组中index位置对应mArray中index*2+1的位置，使用位移操作以提高效率</span><br><span class="line">    return index &gt;= 0 ? (V)mArray[(index&lt;&lt;1)+1] : null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>删除元素。删除后当元素个数低于数组长度的1/3，并且数组的长度大于BASE_SIZE*2时，出发数组压缩。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">public V removeAt(int index) &#123;</span><br><span class="line">    final Object old = mArray[(index &lt;&lt; 1) + 1];//又是神秘操作，待会再看用来干嘛的</span><br><span class="line">    if (mSize &lt;= 1) &#123;//如果数组为空或者只有一个元素，那么直接将数组置空即可</span><br><span class="line">        freeArrays(mHashes, mArray, mSize);//又看到这个待会要收拾的方法了</span><br><span class="line">        mHashes = EmptyArray.INT;//置空，INT为一个大小为0的int数组</span><br><span class="line">        //奇怪的作者为什么要使用这个置空方法，是因为简洁嘛？真想问问他</span><br><span class="line">        mArray = EmptyArray.OBJECT;//置空,OBJECT为一个大小为0的Object数组</span><br><span class="line">        mSize = 0;//数组大小置0</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //当数组长度大于BASE_SIZE*2=8并且当前元素数量小于总容量的1/3时</span><br><span class="line">        if (mHashes.length &gt; (BASE_SIZE*2) &amp;&amp; mSize &lt; mHashes.length/3) &#123;</span><br><span class="line">            // 嘿嘿，通过下面的英文注释，可以看到下面的操作是在干嘛了</span><br><span class="line">            // Shrunk enough to reduce size of arrays.  We don&#x27;t allow it to</span><br><span class="line">            // shrink smaller than (BASE_SIZE*2) to avoid flapping between</span><br><span class="line">            // that and BASE_SIZE.</span><br><span class="line">            //翻译过来就是，收缩足够的空间来减少数组大小，也就是说这样是为了避免连续</span><br><span class="line">            //删除元素导致大量无用内存，这些内存需要及时释放,以提高内存效率</span><br><span class="line">            //（哎，再感叹一次，为了一点点点点的内存，设计人员真的是煞费苦心啊）</span><br><span class="line">            //但是注释里也说了，还要控制数组不能收缩到小于8的值，以避免“抖动”</span><br><span class="line">            //这个抖动我本来想具体解释下的，但是我感觉这个东西完全可以意会，我就不言传了</span><br><span class="line">            //所以就留给你们自己感受这个“抖动”吧！哈哈</span><br><span class="line">            </span><br><span class="line">            //计算新的容量，如果大于8，那么就收缩为当前元素数量的1.5倍，否则，就置为8</span><br><span class="line">            final int n = mSize &gt; (BASE_SIZE*2) ? (mSize + (mSize&gt;&gt;1)) : (BASE_SIZE*2);</span><br><span class="line">            //保存当前数组的值</span><br><span class="line">            final int[] ohashes = mHashes;</span><br><span class="line">            final Object[] oarray = mArray;</span><br><span class="line">            //又看到allocArrays这个方法了，嘿嘿，现在我们知道他是干嘛的了</span><br><span class="line">            allocArrays(n);//浓缩成一句话：复用内存以初始化mHashes数组和mArray数组</span><br><span class="line">            //数组元素减一</span><br><span class="line">            mSize--;</span><br><span class="line">            //如果删除的下标index值大于0，则赋值以恢复mHashes和mArray数组index之前的数据</span><br><span class="line">            if (index &gt; 0) &#123;</span><br><span class="line">                //将之前保存的数组的值赋值给初始化之后的mHashes和mArray数组，恢复数据</span><br><span class="line">                //但是注意到第五个参数index，表示这一步只是赋值了删除元素index之前的数据</span><br><span class="line">                if (DEBUG) Log.d(TAG, &quot;remove: copy from 0-&quot; + index + &quot; to 0&quot;);</span><br><span class="line">                System.arraycopy(ohashes, 0, mHashes, 0, index);</span><br><span class="line">                System.arraycopy(oarray, 0, mArray, 0, index &lt;&lt; 1);</span><br><span class="line">            &#125;</span><br><span class="line">            //如果index小于容器元素数量，则赋值index之后的数据</span><br><span class="line">            if (index &lt; mSize) &#123;</span><br><span class="line">                //对mHashes数组和mArray数组作前移操作，前移index位置以后的元素</span><br><span class="line">                System.arraycopy(ohashes, index + 1, mHashes, index, mSize - index);</span><br><span class="line">                //当然对mArray来说，就是前移index*2+2之后的数据元素</span><br><span class="line">                System.arraycopy(oarray, (index + 1) &lt;&lt; 1, mArray, index &lt;&lt; 1, (mSize - index) &lt;&lt; 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;//当前数组容量&lt;8或者大于总容量的1/3时，不需要收缩数组容量</span><br><span class="line">            mSize--;//直接减小1</span><br><span class="line">            if (index &lt; mSize) &#123;</span><br><span class="line">                //前移index之后的元素</span><br><span class="line">                System.arraycopy(mHashes, index + 1, mHashes, index, mSize - index);</span><br><span class="line">                //前移index*2+2之后的元素</span><br><span class="line">                System.arraycopy(mArray, (index + 1) &lt;&lt; 1, mArray, index &lt;&lt; 1, (mSize - index) &lt;&lt; 1);</span><br><span class="line">            &#125;</span><br><span class="line">            //前移后，最后一个元素空出来了，及时置空，以释放内存</span><br><span class="line">            mArray[mSize &lt;&lt; 1] = null;</span><br><span class="line">            mArray[(mSize &lt;&lt; 1) + 1] = null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //呼！分析完了</span><br><span class="line">    return (V)old;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>优缺点</p>
</li>
</ol>
<ul>
<li>优点：内存利用率高，具有空间压缩机制。虽然二分法查询效率相比map底，但是通过索引迭代效率却高过map。</li>
<li>缺点：存取复杂度高。二分法查找比map底。没有实现Serializable，不利于bundle传输。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/hq942845204/article/details/81293480">参考</a></p>
<h4 id="SparseArray"><a href="#SparseArray" class="headerlink" title="SparseArray"></a>SparseArray</h4><ol>
<li><p>底层采用双数组分别存储key和value，key只能是int类型存储时会排序。采用SparseArray相比map可以提高内存使用效率，针对移动开发来说很有用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class SparseArray&lt;E&gt; implements Clonable&#123;</span><br><span class="line">    private boolean mGarbage = false; // 是否需要调用gc();</span><br><span class="line">    private int[] mKeys; // 存储key</span><br><span class="line">    private Object[] mValues; // 存储value</span><br><span class="line">    private int mSize; // 数组中元素的个数</span><br><span class="line">    //</span><br><span class="line">    public SparseArray() &#123;</span><br><span class="line">        this(10);</span><br><span class="line">    &#125;</span><br><span class="line">    // </span><br><span class="line">    public SparseArray(int initialCapacity) &#123;</span><br><span class="line">        if (initialCapacity == 0) &#123;</span><br><span class="line">            mKeys = EmptyArray.INT;</span><br><span class="line">            mValues = EmptyArray.OBJECT;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mValues = ArrayUtils.newUnpaddedObjectArray(initialCapacity);</span><br><span class="line">            mKeys = new int[mValues.length];</span><br><span class="line">        &#125;</span><br><span class="line">        mSize = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>添加元素<br>SparseArray添加元素有2个方法put和append，当元素的key大于数组中的key时使用append，否则append会调用put。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">public void put(int key, E value) &#123;</span><br><span class="line">    //利用二分查找，找到 待插入key 的 下标index</span><br><span class="line">    int i = ContainerHelpers.binarySearch(mKeys, mSize, key);</span><br><span class="line">    //如果返回的index是正数，说明之前这个key存在，直接覆盖value即可</span><br><span class="line">    if (i &gt;= 0) &#123;</span><br><span class="line">        mValues[i] = value;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //若返回的index是负数，说明 key不存在.</span><br><span class="line">        </span><br><span class="line">        //先对返回的i取反，得到应该插入的位置i</span><br><span class="line">        i = ~i;</span><br><span class="line">        //如果i没有越界，且对应位置是已删除的标记，则复用这个空间</span><br><span class="line">        if (i &lt; mSize &amp;&amp; mValues[i] == DELETED) &#123;</span><br><span class="line">        //赋值后，返回</span><br><span class="line">            mKeys[i] = key;</span><br><span class="line">            mValues[i] = value;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //如果需要GC，且需要扩容</span><br><span class="line">        if (mGarbage &amp;&amp; mSize &gt;= mKeys.length) &#123;</span><br><span class="line">            //先触发GC</span><br><span class="line">            gc();</span><br><span class="line">            //gc后，下标i可能发生变化，所以再次用二分查找找到应该插入的位置i</span><br><span class="line">            // Search again because indices may have changed.</span><br><span class="line">            i = ~ContainerHelpers.binarySearch(mKeys, mSize, key);</span><br><span class="line">        &#125;</span><br><span class="line">        //插入key（可能需要扩容）</span><br><span class="line">        mKeys = GrowingArrayUtils.insert(mKeys, mSize, i, key);</span><br><span class="line">        //插入value（可能需要扩容）</span><br><span class="line">        mValues = GrowingArrayUtils.insert(mValues, mSize, i, value);</span><br><span class="line">        //集合大小递增</span><br><span class="line">        mSize++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 二分法查找写的比较艺术</span><br><span class="line">static int binarySearch(int[] array, int size, int value) &#123;</span><br><span class="line">    int lo = 0;</span><br><span class="line">    int hi = size - 1;</span><br><span class="line"></span><br><span class="line">    while (lo &lt;= hi) &#123;</span><br><span class="line">        final int mid = (lo + hi) &gt;&gt;&gt; 1;</span><br><span class="line">        final int midVal = array[mid];</span><br><span class="line"></span><br><span class="line">        if (midVal &lt; value) &#123;</span><br><span class="line">            lo = mid + 1;</span><br><span class="line">        &#125; else if (midVal &gt; value) &#123;</span><br><span class="line">            hi = mid - 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return mid;  // 找到了</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ~lo;  // 没找到</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// gc将标记为DELETE的位置释放出来</span><br><span class="line">private void gc() &#123;</span><br><span class="line">    //奇怪的作者没有删掉注释，代码强迫症的我好想给他把这句日志的注释删掉，但是没有权限，嘤嘤嘤！</span><br><span class="line">    // Log.e(&quot;SparseArray&quot;, &quot;gc start with &quot; + mSize);</span><br><span class="line"></span><br><span class="line">    int n = mSize;//压缩前数组的容量</span><br><span class="line">    int o = 0;//压缩后数组的容量，初始为0</span><br><span class="line">    int[] keys = mKeys;//保存新的key值的数组</span><br><span class="line">    Object[] values = mValues;//保存新的value值的数组</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        Object val = values[i];</span><br><span class="line"></span><br><span class="line">        if (val != DELETED) &#123;//如果该value值不为DELETED，也就是没有被打上“删除”的标签</span><br><span class="line">            if (i != o) &#123;//如果前面已经有元素打上“删除”的标签，那么 i 才会不等于 o</span><br><span class="line">                //将 i 位置的元素向前移动到 o 处,这样做最终会让所有的非DELETED元素连续紧挨在数组前面</span><br><span class="line">                keys[o] = keys[i];</span><br><span class="line">                values[o] = val;</span><br><span class="line">                values[i] = null;//释放空间</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            o++;//新数组元素加一</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //回收完毕，置为false</span><br><span class="line">    mGarbage = false;</span><br><span class="line">    //回收之后数组的大小</span><br><span class="line">    mSize = o;</span><br><span class="line">    //哼！，这里的注释也没删</span><br><span class="line">    // Log.e(&quot;SparseArray&quot;, &quot;gc end with &quot; + mSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>获取元素</p>
</li>
<li><p>删除元素</p>
</li>
<li><p>优缺点</p>
</li>
</ol>
<ul>
<li>优点：内存利用率高，具有”gc”机制。频繁插入删除效率高，有延迟删除机制。</li>
<li>缺点：二分法查找效率低于map。key只能是int或者long。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/1739363c0e50">参考</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/adison/p/3615375.html">参考</a></p>
<h3 id="结构体部分"><a href="#结构体部分" class="headerlink" title="结构体部分"></a>结构体部分</h3><h4 id="Pair"><a href="#Pair" class="headerlink" title="Pair"></a>Pair</h4><ol>
<li>Pair用于存储一组对象的数据结构，内部是两个final类型的first和second属性。</li>
<li>equals通过值比较，判断first和second的值。</li>
<li>利用Pair和List结合，形成类似Map的效果。</li>
</ol>
</div><div class="tags"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul></div><div class="post-nav"><a class="pre" href="/computics/%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/">常用算法整理</a><a class="next" href="/computics/android/android%E7%9A%84%E5%90%AF%E5%8A%A8/">android的启动</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://huscarter.com"/></form></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="About"><img class="nofancybox" src="/img/avatar.png"/></a><p>Here to stay.</p><a class="info-icon" href="https://twitter.com/username" title="Twitter" target="_blank" style="margin-inline:5px"> <i class="fa fa-twitter-square" style="margin-inline:5px"></i></a><a class="info-icon" href="mailto:admin@domain.com" title="Email" target="_blank" style="margin-inline:5px"> <i class="fa fa-envelope-square" style="margin-inline:5px"></i></a><a class="info-icon" href="https://www.github.com/huscarter" title="Github" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a><a class="info-icon" href="/atom.xml" title="RSS" target="_blank" style="margin-inline:5px"> <i class="fa fa-rss-square" style="margin-inline:5px"></i></a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/computics/">computics</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/computics/android/">android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/computics/flutter/">flutter</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/computics/j2ee/">j2ee</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/computics/web/">web</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/computics/%E5%B0%8F%E7%A8%8B%E5%BA%8F/">小程序</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/computics/%E6%8A%80%E6%9C%AF%E5%91%A8%E8%BE%B9/">技术周边</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/computics/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/computics/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/computics/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/">版本控制</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/computics/%E7%AE%97%E6%B3%95/">算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/computics/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/">计算机语言</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/computics/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/economics/">economics</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/economics/%E5%95%86%E5%AD%A6%E9%99%A2/">商学院</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/history/">history</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/history/%E8%AE%BA%E5%8F%A4%E8%AF%B4%E4%BB%8A/">论古说今</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/language/">language</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/language/%E6%97%A5%E8%AF%AD/">日语</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/language/%E8%8B%B1%E8%AF%AD/">英语</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/literature/">literature</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/literature/%E8%AF%97%E6%AD%8C/">诗歌</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/other/">other</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/other/%E5%AE%B6%E8%A3%85/">家装</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/other/%E8%A1%8C%E5%8A%A8%E5%AD%A6%E4%B9%A0/">行动学习</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/psychology/">psychology</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/psychology/%E4%BA%BA%E6%A0%BC%E5%BF%83%E7%90%86%E5%AD%A6/">人格心理学</a></li></ul></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/android/" style="font-size: 15px;">android</a> <a href="/tags/C/" style="font-size: 15px;">C++</a> <a href="/tags/flutter/" style="font-size: 15px;">flutter</a> <a href="/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/" style="font-size: 15px;">快捷键</a> <a href="/tags/maven/" style="font-size: 15px;">maven</a> <a href="/tags/%E7%89%A9%E8%81%94%E7%BD%91/" style="font-size: 15px;">物联网</a> <a href="/tags/%E5%BB%BA%E7%AB%99/" style="font-size: 15px;">建站</a> <a href="/tags/binder/" style="font-size: 15px;">binder</a> <a href="/tags/%E6%8A%80%E6%9C%AF%E5%91%A8%E8%BE%B9/" style="font-size: 15px;">技术周边</a> <a href="/tags/css/" style="font-size: 15px;">css</a> <a href="/tags/es/" style="font-size: 15px;">es</a> <a href="/tags/Go/" style="font-size: 15px;">Go</a> <a href="/tags/jenkins/" style="font-size: 15px;">jenkins</a> <a href="/tags/github/" style="font-size: 15px;">github</a> <a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/glide/" style="font-size: 15px;">glide</a> <a href="/tags/groovy/" style="font-size: 15px;">groovy</a> <a href="/tags/h5/" style="font-size: 15px;">h5</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/kotlin/" style="font-size: 15px;">kotlin</a> <a href="/tags/nexus/" style="font-size: 15px;">nexus</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/tags/proguard/" style="font-size: 15px;">proguard</a> <a href="/tags/python/" style="font-size: 15px;">python</a> <a href="/tags/ssm/" style="font-size: 15px;">ssm</a> <a href="/tags/swift/" style="font-size: 15px;">swift</a> <a href="/tags/%E8%A1%8C%E5%8A%A8%E5%AD%A6%E4%B9%A0/" style="font-size: 15px;">行动学习</a> <a href="/tags/terminal/" style="font-size: 15px;">terminal</a> <a href="/tags/threejs/" style="font-size: 15px;">threejs</a> <a href="/tags/typescript/" style="font-size: 15px;">typescript</a> <a href="/tags/vue/" style="font-size: 15px;">vue</a> <a href="/tags/weex/" style="font-size: 15px;">weex</a> <a href="/tags/%E8%B4%A2%E6%8A%A5/" style="font-size: 15px;">财报</a> <a href="/tags/%E5%88%B7%E6%9C%BA/" style="font-size: 15px;">刷机</a> <a href="/tags/%E4%BA%94%E5%88%86%E9%92%9F%E5%95%86%E5%AD%A6%E9%99%A2/" style="font-size: 15px;">五分钟商学院</a> <a href="/tags/j2ee/" style="font-size: 15px;">j2ee</a> <a href="/tags/web/" style="font-size: 15px;">web</a> <a href="/tags/react/" style="font-size: 15px;">react</a> <a href="/tags/vite/" style="font-size: 15px;">vite</a> <a href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" style="font-size: 15px;">浏览器</a> <a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 15px;">网络</a> <a href="/tags/%E5%8A%A0%E5%AF%86/" style="font-size: 15px;">加密</a> <a href="/tags/%E9%82%A3%E4%BA%9B%E5%B9%B4/" style="font-size: 15px;">那些年</a> <a href="/tags/%E8%82%A1%E7%A5%A8/" style="font-size: 15px;">股票</a> <a href="/tags/%E9%87%8F%E5%8C%96/" style="font-size: 15px;">量化</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 15px;">算法</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 15px;">设计模式</a> <a href="/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/" style="font-size: 15px;">微信小程序</a> <a href="/tags/%E8%AF%BB%E5%90%8E%E6%84%9F/" style="font-size: 15px;">读后感</a> <a href="/tags/%E6%94%AF%E4%BB%98%E5%AE%9D%E5%B0%8F%E7%A8%8B%E5%BA%8F/" style="font-size: 15px;">支付宝小程序</a> <a href="/tags/%E6%97%A5%E8%AF%AD/" style="font-size: 15px;">日语</a> <a href="/tags/%E5%AE%B6%E8%A3%85/" style="font-size: 15px;">家装</a> <a href="/tags/IDE/" style="font-size: 15px;">IDE</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/" style="font-size: 15px;">设计规范</a> <a href="/tags/%E8%8B%B1%E8%AF%AD/" style="font-size: 15px;">英语</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 15px;">数据结构</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/computics/web/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-react%E5%9F%BA%E7%A1%80%E7%AF%87/">前端知识整理-react基础篇</a></li><li class="post-list-item"><a class="post-list-link" href="/computics/web/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-vite%E7%AF%87/">前端知识整理-vite篇</a></li><li class="post-list-item"><a class="post-list-link" href="/computics/android/android%E5%8F%8D%E7%BC%96%E8%AF%91%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/">android反编译知识整理</a></li><li class="post-list-item"><a class="post-list-link" href="/computics/%E7%AE%97%E6%B3%95/%E5%8A%A0%E5%AF%86%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/">加密知识梳理</a></li><li class="post-list-item"><a class="post-list-link" href="/computics/web/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%B5%8F%E8%A7%88%E5%99%A8%E7%AF%87/">前端知识整理-浏览器篇</a></li><li class="post-list-item"><a class="post-list-link" href="/computics/web/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E7%BD%91%E7%BB%9C%E7%AF%87/">前端知识整理-网络篇</a></li><li class="post-list-item"><a class="post-list-link" href="/computics/web/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-vue%E8%BF%9B%E9%98%B6%E7%AF%87/">前端知识整理-vue进阶篇</a></li><li class="post-list-item"><a class="post-list-link" href="/computics/web/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-vue%E5%9F%BA%E7%A1%80%E7%AF%87/">前端知识整理-vue基础篇</a></li><li class="post-list-item"><a class="post-list-link" href="/computics/web/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-vue%E8%AF%AD%E6%B3%95%E7%AF%87/">前端知识整理-vue语法篇</a></li><li class="post-list-item"><a class="post-list-link" href="/computics/web/es5%E5%92%8Ces6%E7%9A%84%E5%8C%BA%E5%88%AB/">es5和es6的区别</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Links</i></div><ul></ul><a href="https://blog.konghy.cn/" title="favorites:konghy" target="_blank">favorites:konghy</a><ul></ul><a href="http://www.ruanyifeng.com/blog/" title="favorites:ruanyf" target="_blank">favorites:ruanyf</a><ul></ul><a href="https://www.liaoxuefeng.com/" title="廖雪峰" target="_blank">廖雪峰</a><ul></ul><a href="https://www.ruanyifeng.com/" title="阮一峰" target="_blank">阮一峰</a><ul></ul><a href="http://tengj.top/" title="嘟嘟独立技术" target="_blank">嘟嘟独立技术</a><ul></ul><a href="https://hellogithub.com/" title="hellogithub" target="_blank">hellogithub</a><ul></ul><a href="https://www.cnblogs.com/xiaolincoding" title="小林博客园" target="_blank">小林博客园</a><ul></ul><a href="https://yelog.org/" title="落叶阁" target="_blank">落叶阁</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2024 <a href="/." rel="nofollow">Here to stay.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="Copy Successed!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>